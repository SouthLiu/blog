# vue和react的区别
Vue 的学习曲线较低、库大小更小，在响应式编程和组件化方面让用户更易上手；而 React 使用 JSX 语法来渲染 UI，具有良好的性能，不过它的学习曲线比 Vue 高，也需要更多的资源加载。

1. 数据可变性
* React 推崇函数式编程，数据不可变以及单向数据流，只能通过setState或者onchange来实现视图更新
* Vue 基于数据可变，设计了响应式数据，通过监听数据的变化自动更新视图

2. 写法
* React 推荐使用 jsx + inline style的形式，就是 all in js
* Vue 是单文件组件（SFC）形式，在一个组件内分模块(tmplate/script/style)，当然vue也支持jsx形式，可以在开发vue的ui组件库时使用

3. diff算法
* Vue2采用双端比较，Vue3采用快速比较
* react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。，需要使用`shouldComponentUpdate()`来手动优化react的渲染。

# SFC是什么
SFC（Single File Component）是Vue.js中的一种模板文件，它将HTML，CSS，JavaScript和其他语言组合在一个文件中，可以帮助开发人员简化前端开发工作，并更好地控制代码的可维护性和可读性。

# vue组件通信方式
* props / $emit
* ref / $refs
* parent/parent / parent/root
* attrs / listeners
* eventBus / vuex / pinia / localStorage / sessionStorage / Cookie / window
* provide / inject

# vue 渲染列表为什么要加key?
Vue 在处理更新同类型 vnode 的一组子节点（比如v-for渲染的列表节点）的过程中，为了减少 DOM 频繁创建和销毁的性能开销。

对没有 key 的子节点数组更新是通过**就地更新**的策略。它会通过对比新旧子节点数组的长度，先以比较短的那部分长度为基准，将新子节点的那一部分直接 patch 上去。然后再判断，如果是新子节点数组的长度更长，就直接将新子节点数组剩余部分挂载；如果是新子节点数组更短，就把旧子节点多出来的那部分给卸载掉）。**所以如果子节点是组件或者有状态的 DOM 元素，原有的状态会保留，就会出现渲染不正确的问题。**

有 key 的子节点更新是调用的patchKeyedChildren，这个函数就是大家熟悉的实现核心 diff 算法的地方，大概流程就是同步头部节点、同步尾部节点、处理新增和删除的节点，最后用求解最长递增子序列的方法区处理未知子序列。是为了**最大程度实现对已有节点的复用，减少 DOM 操作的性能开销**，同时避免了就地更新带来的子节点状态错误的问题。

# vue3 相对 vue2的响应式优化
vue2使用的是`Object.defineProperty`去监听对象属性值的变化，但是它不能监听对象属性的新增和删除，所以需要使用`$set`、`$delete`这种语法糖去实现，这其实是一种设计上的不足。

所以 vue3 采用了`proxy`去实现响应式监听对象属性的增删查改。

其实从api的原生性能上`proxy`是比`Object.defineProperty`要差的。

而 vue 做的响应式性能优化主要是在将嵌套层级比较深的对象变成响应式的这一过程。

vue2的做法是在组件初始化的时候就递归执行`Object.defineProperty`把子对象变成响应式的；

而vue3是在访问到子对象属性的时候，才会去将它转换为响应式。这种延时定义子对象响应式会对性能有一定的提升

# Vue 核心diff流程

前提：当同类型的 vnode 的子节点都是一组节点（数组类型）的时候，

步骤：会走核心 diff 流程

Vue3是快速选择算法:
* 同步头部节点
* 同步尾部节点
* 新增新的节点
* 删除多余节点
* 处理未知子序列（贪心 + 二分处理最长递增子序列）

Vue2是双端比较算法:
在新旧字节点的头尾节点，也就是四个节点之间进行对比，找到可复用的节点，不断向中间靠拢的过程

diff目的：diff 算法的目的就是为了尽可能地复用节点，减少 DOM 频繁创建和删除带来的性能开销

# Vue双向绑定原理
基于 MVVM 模型，viewModel(业务逻辑层)提供了数据变化后更新视图和视图变化后更新数据这样一个功能，就是传统意义上的双向绑定。

Vue2: 双向绑定原理是使用Object.defineProperty来实现响应式处理，当数据发生变化时，会自动更新 DOM，从而实现双向绑定的效果。它使用一种观察者模式，订阅者是 Reactivity 树中的每一个属性，当数据发生变化时，它会通知这些订阅者，从而实现数据变化的双向绑定。

Vue3：使用了Proxy来替代Object.defineProperty实现数据响应式，从而使得双向绑定更加高效。收集副作用到桶中，每次数据更新或读取时调用副作用桶，从而更新渲染视图。