# Promise主要解决什么问题？
```
Promise解决了回调地狱的问题
```

# 说说Promise缺点
1. 一旦创建就会立即执行，无法中途取消。
2. 如果不设置回调函数，Promise内部抛出错误。
3. 当处于Pending状态时，无法得知目前进展到哪一阶段。

# 本地存储方式
* sessionStorage
* localStorage
* cookie

# sessionStorage
sessionStorage仅在当前会话下有效，关闭页面或浏览器清除。

# localStorage
长久保存数据，没有过期时间，直到手动去删除。

# cookie
存储于你电脑上的文本文件中，用于存储web页面的用户信息。

# vue和react的区别
Vue 的学习曲线较低、库大小更小，在响应式编程和组件化方面让用户更易上手；而 React 使用 JSX 语法来渲染 UI，具有良好的性能，不过它的学习曲线比 Vue 高，也需要更多的资源加载。

1. 数据可变性
* React 推崇函数式编程，数据不可变以及单向数据流，只能通过setState或者onchange来实现视图更新
* Vue 基于数据可变，设计了响应式数据，通过监听数据的变化自动更新视图

2. 写法
* React 推荐使用 jsx + inline style的形式，就是 all in js
* Vue 是单文件组件（SFC）形式，在一个组件内分模块(tmplate/script/style)，当然vue也支持jsx形式，可以在开发vue的ui组件库时使用

3. diff算法
* Vue2采用双端比较，Vue3采用快速比较
* react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。需要使用`shouldComponentUpdate()`来手动优化react的渲染。

# 什么是闭包?
```
一个函数能够读取其他函数内部变量的函数。
```

# 闭包用处？
1. 可以读取函数内部变量。
2. 这个函数值始终保持不变。

# 闭包应用场景
1. Ajax请求的成功回调。
2. 事件绑定的回调。
3. setTimeout延时回调。

# 闭包缺点
1. 代码难以维护。闭包能访问上级作用域，而闭包执行是异步的，一定要清楚上级作用域发生了什么。
2. 闭包会使得函数一直保存在内存中，内存消耗大，会造成内存泄漏。

# 内存泄漏
```
应用程序不需要被内存占用的时候，因为一些原因无法被内存池回收。
```
# 闭包是什么？
闭包指那些调用另外一个函数作用域中变量的函数，通常是嵌套函数中实现的。

# 什么是原型和原型链？
* 原型是指JavaScript中对象继承的一种方式，它可以使JavaScript对象能够从其他对象继承属性和方法。
* 原型链是指每个对象都有一个指向另一个对象的隐式连接，并且一系列的这样的连接形成了一条“链”，用于在对象层次结构之间查找属性和方法。

# this的指向
1. 全局的this非严格模式指向window对象，严格模式指向 undefined。
2. 对象的属性方法中的this 指向对象本身。
3. apply、call、bind 可以变更 this 指向为第一个传参。
4. 箭头函数中的this指向它的父级作用域，它自身不存在 this。

# apply，call，bind三者的区别
1. 三者都可以改变函数的this对象指向。
2. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。
3. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。
bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。

# BFC是什么？
BFC是**块级格式上下文**。你可以把BFC看做一个容器，容器里边元素不会影响到容器外部元素。

# BFC特点：
1. BFC是一个**块级元素**，块级元素在垂直方向上依次排列。
2. BFC是一个独立的容器，内部元素不会影响容器外部的元素。
3. 属于同一个BFC的两个盒子，**外边距margin**会发生重叠，并且取最大外边距。

# BFC的触发条件?
1. 根元素。
2. 浮动元素。元素的float不是none。
3. 绝对定位元素。元素的position为absolute或fixed。
4. 行内块元素。元素的 display 为 inline-block；
5. 表格单元格。元素的 display为 table-cell，HTML表格单元格默认为该值；
6. 表格标题。元素的 display 为 table-caption，HTML表格标题默认为该值；
7. 匿名表格单元格元素。元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table；
8. overflow 值不为 visible 的块元素 ；
9. 弹性元素。display为 flex 或 inline-flex元素的直接子元素；
10. 网格元素。display为 grid 或 inline-grid 元素的直接子元素。

# HTTP缓存机制？
分为**强缓存**和**协商缓存**。

* 强缓存：强缓存不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码，并且`size`显示`from disk cache`或`from memory cache`；
* 协商缓存：协商缓存会先向服务器发送一个请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源。

# hash路由模式和history路由模式会请求服务器吗？
在使用 hash 路由模式时，浏览器会在 URL 中添加一个 # 字符，并将其之后的内容作为锚点。这个锚点并不会发送给服务器，而是由浏览器本地处理的。所以，使用 hash 路由模式时，浏览器不会向服务器发送请求。

相反，在使用 history 路由模式时，浏览器会向服务器发送请求，以便获取对应的内容。这种方式的优点是可以使用浏览器的前进和后退按钮来导航，但缺点是需要服务器的支持，因为服务器需要提供对应的内容。

# js中的堆栈是什么？
**基本数据类型**变量保存在**栈内存**中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。
* string
* number
* boolean
* null
* undefined
* symbol
* bigInt

**引用数据类型**存储在**堆内存**中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。
* Array
* Function
* Object

# 浏览器的事件循环？
1. js代码执行过程中，会创建对应的执行上下文并压入执行上下文栈中。
2. 如果遇到异步任务就会将任务挂起，交给其他线程去处理异步任务，当异步任务处理完后，会将回调结果加入事件队列中。
3. 当执行栈中所有任务执行完毕后，就是主线程处于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把这个回调加入执行栈中然后执行其中的代码，如此反复，这个过程就被称为事件循环。
4. 事件队列分为了宏任务队列和微任务队列，在当前执行栈为空时，主线程回先查看微任务队列是否有事件存在，存在则依次执行微任务队列中的事件回调，直至微任务队列为空；不存在再去宏任务队列中处理。

常见的**宏任务**有setTimeout()、setInterval()、setImmediate()、I/O、用户交互操作，UI渲染
常见的**微任务**有promise.then()、promise.catch()、new MutationObserver、process.nextTick()

宏任务和微任务的本质区别：
* 宏任务有明确的异步任务需要执行和回调，需要其他异步线程支持
* 微任务没有明确的异步任务需要执行，只有回调，不需要其他异步线程支持。

# Javascript中数据在栈和堆中的存储方式
JavaScript 将基本类型数据存储在栈中，而对象和数组则存储在堆中。基本类型数据是按值存储的，而对象和数组则是按引用存储的。

# 讲讲v8垃圾回收
V8垃圾回收（GC）是V8引擎的自动垃圾收集技术，它可以帮助我们管理内存、释放内存，以及清除无用的内存。V8的GC使用了不同的技术来进行垃圾回收，如标记-清除法、 标记-整理法、评估-析构法、复制算法、scavenge算法等。

**标记-清除法**是一种最常用的垃圾收集算法，它先标记未使用的对象，然后清除所有标记的对象，从而释放未使用的内存空间。标记清除算法可以有效的回收内存中未使用的对象，但是会带来额外的开销，因为需要遍历整个内存空间来找出未使用的对象。

**标记-整理法**在收集垃圾时，首先将未使用的对象进行标记，然后整理内存空间，把使用中的对象往一端移动，把可以释放的对象往另一端移动，最后清理出不可用的内存空间。标记整理算法能够有效的节省内存，但是会因为频繁的内存整理而增加开销。

**评估-析构法**是一种保护模式垃圾收集技术，它在执行垃圾回收时，会先评估对象的引用情况，然后根据情况将可释放的对象，进行垃圾回收，从而有效的释放内存空间。评估-析构法不仅可以改善内存使用率，还可以减少内存泄漏的发生。

**复制算法**是将内存分为两部分，可用内存和不可用内存，将对象从不可用内存中复制到可用内存中，然后释放原来不可用内存的空间，从而有效的释放内存。

**scavenge算法**是不断地搜索可被回收内存，将这些内存释放给系统使用。当搜索可被回收内存时，scavenge算法会根据对象是否有被引用来进行垃圾收集。如果没有被引用，则会被收集，从而释放占用的空间，维护系统的内存使用情况。

# 浏览器输入url后经历的过程?
1. 首先，在浏览器地址栏中输入url
2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。
4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
5. 握手成功后，浏览器向服务器发送http请求，请求数据包。
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到HTTP响应
8. 读取页面内容，浏览器渲染，解析html源码
9. 生成Dom树、解析css样式、js交互
10. 客户端和服务器交互
11. ajax查询

# DNS解析IP地址的过程？
DNS（Domain Name System）解析是一种用于将域名转换为IP地址的技术。当用户在浏览器中输入一个域名时，DNS解析器会将其转换为对应的IP地址，以便浏览器能够连接到正确的服务器。

DNS解析的过程包括以下几个步骤：
1. **浏览器缓存查询**：浏览器会先检查自己的缓存中是否有对应域名的IP地址，如果有，则直接使用该地址。
2. **本地DNS查询**：如果浏览器缓存中没有找到对应的IP地址，浏览器会向本地DNS服务器发送询问。这些DNS服务器通常由用户的网络提供商提供。
3. **根域名服务器查询**：如果本地DNS服务器没有找到对应的IP地址，它会向根域名服务器发送询问。根域名服务器是所有域名解析的最顶层DNS服务器。
4. **权威DNS服务器查询**：根域名服务器会指示本地DNS服务器向与该域名对应的权威DNS服务器发送询问。权威DNS服务器维护着该域名的DNS记录，并能够提供该域名对应的IP地址

# defer和async的区别？
async和defer能将script的下载阶段变成异步执行（和 html解析同步进行）。

* defer总是在页面解析完成后执行，但是不会阻塞页面的渲染。有执行顺序，先定义的先被执行。
* async会在加载完成后立即执行，但是会阻塞页面的渲染。有执行顺序，只要加载完成就会立即执行。

# 浏览器事件机制
DOM事件流由三个阶段组成：捕获阶段、目标阶段和冒泡阶段。
1. **捕获阶段**：事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件。为了让事件到达最终目标之前拦截事件。
  比如点击一个div，则 click 事件会按这种顺序触发: document => \<html\> => \<body\> => \<div\>，即由 document 捕获后沿着 DOM 树依次向下传播，并在各节点上触发捕获事件，直到到达实际目标元素。
2. **目标阶段**：当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发(执行事件对应的函数)，然后会逆向回流，直到传播至最外层的文档节点。
3. **冒泡阶段**：事件在目标元素上触发后，会继续随着 DOM 树一层层往上冒泡，直到到达最外层的根节点。

所有事件都要经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获得焦点 focus 和失去焦点 blur 不会冒泡。

# e.target 和 e.currentTarget 区别？
* e.target 指的是触发事件时，用户点击的元素。
* e.currentTarget 是指当前正在处理事件的元素，它可能不止一个，比如通过冒泡机制，可能会触发除了被点击的元素外的另一些元素的事件处理程序。

```js
<ul>
  <li><span>hello 1</span></li>
</ul>
​
let ul = document.querySelectorAll('ul')[0]
let aLi = document.querySelectorAll('li')
ul.addEventListener('click',function(e){
  let oLi1 = e.target  
  let oLi2 = e.currentTarget
  console.log(oLi1)   //  被点击的li
  console.log(oLi2)   // ul
  console.og(oLi1===oLi2)  // false
})
```

# 首屏有哪些优化手段？
1. 缩小图像的大小，以便更快的加载。
2. 使用异步加载技术，例如异步 JavaScript 和异步 CSS，来减少阻塞渲染。
3. 使用内容分发网络 (CDN)，以便让用户从更近的服务器获取内容。
4. 使用 gzip 压缩技术来减小文件大小。
5. 缓存静态资源，以便在用户再次访问时能够更快的加载。
6. 减少重定向，以便更快的响应用户的请求。
7. 优化网站的代码，例如合并代码和删除无用的代码，以便更快的执行。

# Webpack怎么打包ES6？
Webpack是一个流行的JavaScript模块打包工具，可以将多个模块打包为一个或多个文件，便于浏览器加载和使用。

要使用Webpack打包ES6，需要在项目中安装Webpack和相应的babel插件，并在Webpack的配置文件（通常是webpack.config.js）中进行如下配置：

1. 在webpack.config.js文件的module.exports对象中，添加一个module属性，用于配置打包规则。
2. 在module属性中，添加一个rules数组，用于配置每个模块的打包规则。
3. 在rules数组中，添加一个规则对象，用于指定如何处理扩展名为.js的文件。该规则对象应该包含两个属性：test和use。

* test属性用于指定哪些文件应该被该规则处理。通常可以使用正则表达式匹配文件名。
* use属性用于指定如何处理匹配到的文件。通常可以指定一个或多个babel插件，用于将ES6代码转换为ES5代码。
例如，如果要使用babel-loader插件将所有扩展名为.js的文件转换为ES5代码，可以使用以下规则：
```
module: {
  rules: [
    {
      test: /\.js$/,
      use: ['babel-loader']
    }
  ]
}
```

# Web安全？
Web安全的一些方法包括：使用加密技术（如HTTPS）来保护数据传输；实施安全策略，限制不必要的网络请求；使用可靠的身份验证和授权机制；实施系统安全控制，如防火墙；实施应用程序安全控制，如输入验证；以及实施强大的日志监控系统。

前端安全的一些方法包括：使用安全的通信协议（如HTTPS）来保护数据传输；实施安全策略，限制不必要的网络请求；使用可靠的身份验证和授权机制；避免脚本注入攻击；实施防止XSS攻击的措施；以及使用安全的API。

# Webpack5的好处？
Webpack5拥有几大优势，包括更快的构建，更好的配置管理，JavaScript框架的树摇晃支持以及改进的模块统一。

# 微前端解决了什么痛点？优缺点？
微前端技术能够解决前端现有开发流程的一些痛点，例如复杂的服务器端组件集成、不统一的应用系统架构和弱化的可重用性等。它的优点包括业务组件重用。

# pnpm和yarn有什么优缺点？
PNPM的优点是它可以减少构建时间，并且它拥有独特的资源管理机制，使其成为开发者的理想选择。它的缺点是它的内存使用量非常高。
Yarn的优点是它可以从模块仓库中获取最新的软件包，并且它的安装速度非常快。此外，Yarn的内存使用效率也很高，因此能够提高构建性能。它的缺点是它不能共享资源。

# 前端性能指标有哪些？
前端性能指标包括：页面加载时间（Page Load Time）、白屏时间（First Paint Time）、DOM Ready 时间（DOM Ready Time）、用户可操作时间（User-Interactive Time）、资源加载速度（Resource Download Speed）、资源加载时间（Resource Load Time）、内存使用情况（Memory Usage）以及 CPU 使用（CPU Usage）等指标。

# Service Worker有什么作用？
Service Worker主要用于提升网页和应用的性能，它可以缓存资源和请求，从而使得页面加载速度更快，并且可以在离线状态下提供服务。它还可以接收 push 通知，从而可以实现后台自动更新，用户体验也会更好。

# JSONP跨域
jsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

```html
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```
# vue组件如何通信？
* props/$emit
* $on/$emit
* Vuex

# js为什么会有事件循环机制
### JavaScript是一种单线程的编程语言，意思就是同一时间段只能做一件事，所有任务都需要排队依次完成；
### 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
### JavaScript开发人员意识到，为了不影响主线程正常运行，就把那些耗时的时间（比如定时器，Ajax操作从网络读取数据等）任务挂起来，依次的放进一个任务队列中，等主线程的任务执行完毕后，再回过来去继续执行队列中的任务；

# 浏览器解析并渲染页面过程
1. 浏览器获取html资源后开始解析html(dom tree)。
2. 解析到css后根据css生成css规则树(style rules)。
3. 在dom树和css规则树都生成完成后，通过dom树和css规则树生产渲染树(render tree)。
4. 渲染树构建完成后，浏览器开始计算元素的大小和位置。
5. 根据计算好的节点信息将内容绘制到屏幕上(painting)。

# 重绘和重拍
* 部分渲染树(或者整个渲染树)需要重新分析并且节点尺寸需要重新计算。这称为**重排**。
* 由于几个节点的属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新称为**重绘**。

# 什么情况会触发重排和重绘？
* 添加、删除、更新DOM节点
* 通过 display: none 隐藏一个DOM节点-触发重绘和重排。
* 通过 visibility: hidden 隐藏一个DOM节点-只触发重绘，因为没有几何变化。
* 移动或者给页面中的DOM节点添加动画。
* 添加一个样式表，调整样式表。
* 用户行为。例如调整窗口大小、改变字号、或者滚动。

# 回流
```
在布局之后对元素的大小、位置发生改变时，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树。
```

# ES6新特性？
* symbol
* let和const
* 解构赋值：let [a, b] = [1, 2]
* Map和Set
* 拓展运算符(...)
* 对象新增：assign和is
* 数组的新方法：from()、find()和findIndex()
* 字符串模板``
* 箭头函数
* class
* 模块导入和导出
* async await
* Promise
* Generator迭代器

# MVC和MVVM区别？
* MVC思想：Controller负责将Model的数据用View显示出来。
* MVVM思想：Model 和 View 并无直接关联，而是通过 ViewModel 来进行交互的（即双向数据绑定）。

MVC优点：
* 耦合度低（运用MVC的应用程序的三个部件是相互独立的，改变其中一个不会影响其他两个）；
* 重用性高（多个视图可以使用同一个模型）
* 生命周期成本低
* 部署快（业务分工明确）
* 可维护性高

MVC缺点：
* 不适合小型项目开发
* 视图与控制器联系过于紧密，妨碍了它们的独立重用

MVVM 优点：
* 低耦合：
  * 视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，
  * 当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；
* 可重用性：你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。
  * 独立开发：双向数据绑定的模式，实现了View和Model的自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要一直操作 dom。

# Vue怎么实现双向绑定？
1. 利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者。
2. 解析器Compile解析模板中的Directive(指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染。
3. Watcher属于Observer和Compile桥梁，它将接收到的Observer产生的数据变化，并根据Compile提供的指令进行视图渲染，使得数据变化促使视图变化。

# Vue为什么v-for为什么要有key？
1. vue中列表循环需加:key="唯一标识" 唯一标识尽量是item里面id等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM。
2. key主要用来做dom diff算法用的，diff算法是同级比较，比较当前标签上的key还有它当前的标签名，如果key和标签名都一样时只是做了一个移动的操作，不会重新创建元素和删除元素。
3. 没有key的时候默认使用的是“就地复用”策略。如果数据项的顺序被改变，Vue不是移动Dom元素来匹配数据项的改变，而是简单复用原来位置的每个元素。如果删除第一个元素，在进行比较时发现标签一样值不一样时，就会复用之前的位置，将新值直接放到该位置，以此类推，最后多出一个就会把最后一个删除掉。
4. 尽量不要使用索引值index作key值，一定要用唯一标识的值，如id等。因为若用数组索引index为key，当向数组中指定位置插入一个新元素后，因为这时候会重新更新index索引，对应着后面的虚拟DOM的key值全部更新了，这个时候还是会做不必要的更新，就像没有加key一样，因此index虽然能够解决key不冲突的问题，但是并不能解决复用的情况。如果是静态数据，用索引号index做key值是没有问题的。
5. 标签名一样，key一样这时候就会就地复用，如果标签名不一样，key一样不会复用。

# Proxy与Object.defineProperty的优劣对比？
* Proxy可以直接监听对象而非属性。
* Proxy可以直接监听数组的变化。
* Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。
* Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而Object.defineProperty只能遍历对象属性直接修改。
* Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。
* Object.defineProperty兼容IE。

# WebSocket怎么实现心跳重连？
1. 前端每隔一段时间向服务器发送一个数据包。
2. 服务器接收到数据立马返回一个数据给前端。
3. 如果没返回或者数据不正确则需要重新连接。
断线重连：在error和close中添加重新连接方法。

# 懒加载图片怎么实现？
1. 渲染图片的时候不添加src，添加一个data-src自定义属性将图片链接放进去。
2. 给定所有图片一个loading图，且添加最小宽度和高度。
3. 通过document.querySelectorAll('img[data-src]')获取到每个图片数组。
4. 遍历图片数据，通过getBoundingClientRect()获取上下左右坐标。
5. 获取当前页面可视高度，当图片上坐标小于这个高度，则渲染图片。
6. 添加滚动事件，每次滚动渲染新的图片，滚动事件添加节流防止多次调用。

# JS的继承有哪些？
1. 原型链继承
2. 借用构造函数继承(借助call)
3. 实例继承
4. 寄生式继承
5. ES6 的 extends 关键字实现逻辑

# react和vue的区别？
共同点：
* 数据驱动视图
* 组件化
* 都使用Virtual DOM

不同点：
* diff算法不同

# react中class和hook区别？
1. class中props是不变的，但this是可变的。
2. class实例都是指向最新的一个实例。

# 为什么函数式要引入hook？
```
因为函数没有状态，所以需要引入hook来管理状态。
```

# 重排的过程做了哪些操作？
重排的过程包括比较、交换、移动和插入等操作。

# WeakSet和数组的区别？
WeakSet和数组的主要区别在于WeakSet中的元素都是弱引用，而数组中的元素是强引用。这意味着WeakSet中的元素可以被垃圾回收机制回收，而数组中的元素不会被回收。此外，WeakSet不能使用数组的方法，例如map，forEach等，而数组可以使用这些方法。

# Set实现原理？
Set是一种数据结构，它用于存储不重复的值。它的实现原理是基于哈希表，它使用哈希函数将元素映射到哈希表中的桶中，以便快速查找和检索元素。Set的实现可以使用链表或数组来存储元素，以提高查找和检索的效率。

# 哪些操作操作DOM会影响性能？
操作DOM会影响性能的操作包括：添加、删除、移动、复制、更改样式、更改内容等。这些操作都会导致浏览器重新渲染页面，从而影响性能。

# 作用域主要分为哪几类？
* 全局作用域
* 函数(局部)作用域
* 块级作用域

# 局部作用域和块级作用域的区别？
在局部作用域中使用var定义变量，无法在全局中访问，而块级可以。

```js
function fun() {
  const a = 1;
  var b = 2;
}
fun()

if (true) {
  const c = 3;
  var d = 4;
}

console.log(a); // a is not defined
console.log(b); // b is not defined
console.log(c); // c is not defined
console.log(d); // 4
```
