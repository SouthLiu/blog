# 闭包是什么？
闭包指那些调用另外一个函数作用域中变量的函数，通常是嵌套函数中实现的。

# 什么是原型和原型链？
* 原型是指JavaScript中对象继承的一种方式，它可以使JavaScript对象能够从其他对象继承属性和方法。
* 原型链是指每个对象都有一个指向另一个对象的隐式连接，并且一系列的这样的连接形成了一条“链”，用于在对象层次结构之间查找属性和方法。

# this的指向
1. 全局的this非严格模式指向window对象，严格模式指向 undefined。
2. 对象的属性方法中的this 指向对象本身。
3. apply、call、bind 可以变更 this 指向为第一个传参。
4. 箭头函数中的this指向它的父级作用域，它自身不存在 this。

# apply，call，bind三者的区别
1. 三者都可以改变函数的this对象指向。
2. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。
3. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。
bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。

# BFC是什么？
BFC是**块级格式上下文**。你可以把BFC看做一个容器，容器里边元素不会影响到容器外部元素。

# BFC特点：
1. BFC是一个**块级元素**，块级元素在垂直方向上依次排列。
2. BFC是一个独立的容器，内部元素不会影响容器外部的元素。
3. 属于同一个BFC的两个盒子，**外边距margin**会发生重叠，并且取最大外边距。

# BFC的触发条件?
1. 根元素。
2. 浮动元素。元素的float不是none。
3. 绝对定位元素。元素的position为absolute或fixed。
4. 行内块元素。元素的 display 为 inline-block；
5. 表格单元格。元素的 display为 table-cell，HTML表格单元格默认为该值；
6. 表格标题。元素的 display 为 table-caption，HTML表格标题默认为该值；
7. 匿名表格单元格元素。元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table；
8. overflow 值不为 visible 的块元素 ；
9. 弹性元素。display为 flex 或 inline-flex元素的直接子元素；
10. 网格元素。display为 grid 或 inline-grid 元素的直接子元素。

# HTTP缓存机制？
分为**强缓存**和**协商缓存**。

* 强缓存：强缓存不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码，并且`size`显示`from disk cache`或`from memory cache`；
* 协商缓存：协商缓存会先向服务器发送一个请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源。

# hash路由模式和history路由模式会请求服务器吗？
在使用 hash 路由模式时，浏览器会在 URL 中添加一个 # 字符，并将其之后的内容作为锚点。这个锚点并不会发送给服务器，而是由浏览器本地处理的。所以，使用 hash 路由模式时，浏览器不会向服务器发送请求。

相反，在使用 history 路由模式时，浏览器会向服务器发送请求，以便获取对应的内容。这种方式的优点是可以使用浏览器的前进和后退按钮来导航，但缺点是需要服务器的支持，因为服务器需要提供对应的内容。

# js中的堆栈是什么？
**基本数据类型**变量保存在**栈内存**中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。
* string
* number
* boolean
* null
* undefined
* symbol
* bigInt

**引用数据类型**存储在**堆内存**中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。
* Array
* Function
* Object

# 浏览器的事件循环？
1. js代码执行过程中，会创建对应的执行上下文并压入执行上下文栈中。
2. 如果遇到异步任务就会将任务挂起，交给其他线程去处理异步任务，当异步任务处理完后，会将回调结果加入事件队列中。
3. 当执行栈中所有任务执行完毕后，就是主线程处于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把这个回调加入执行栈中然后执行其中的代码，如此反复，这个过程就被称为事件循环。
4. 事件队列分为了宏任务队列和微任务队列，在当前执行栈为空时，主线程回先查看微任务队列是否有事件存在，存在则依次执行微任务队列中的事件回调，直至微任务队列为空；不存在再去宏任务队列中处理。

常见的**宏任务**有setTimeout()、setInterval()、setImmediate()、I/O、用户交互操作，UI渲染
常见的**微任务**有promise.then()、promise.catch()、new MutationObserver、process.nextTick()

宏任务和微任务的本质区别：
* 宏任务有明确的异步任务需要执行和回调，需要其他异步线程支持
* 微任务没有明确的异步任务需要执行，只有回调，不需要其他异步线程支持。

# Javascript中数据在栈和堆中的存储方式
JavaScript 将基本类型数据存储在栈中，而对象和数组则存储在堆中。基本类型数据是按值存储的，而对象和数组则是按引用存储的。

# 讲讲v8垃圾回收
V8垃圾回收（GC）是V8引擎的自动垃圾收集技术，它可以帮助我们管理内存、释放内存，以及清除无用的内存。V8的GC使用了不同的技术来进行垃圾回收，如标记-清除法、 标记-整理法、评估-析构法、复制算法、scavenge算法等。

**标记-清除法**是一种最常用的垃圾收集算法，它先标记未使用的对象，然后清除所有标记的对象，从而释放未使用的内存空间。标记清除算法可以有效的回收内存中未使用的对象，但是会带来额外的开销，因为需要遍历整个内存空间来找出未使用的对象。

**标记-整理法**在收集垃圾时，首先将未使用的对象进行标记，然后整理内存空间，把使用中的对象往一端移动，把可以释放的对象往另一端移动，最后清理出不可用的内存空间。标记整理算法能够有效的节省内存，但是会因为频繁的内存整理而增加开销。

**评估-析构法**是一种保护模式垃圾收集技术，它在执行垃圾回收时，会先评估对象的引用情况，然后根据情况将可释放的对象，进行垃圾回收，从而有效的释放内存空间。评估-析构法不仅可以改善内存使用率，还可以减少内存泄漏的发生。

**复制算法**是将内存分为两部分，可用内存和不可用内存，将对象从不可用内存中复制到可用内存中，然后释放原来不可用内存的空间，从而有效的释放内存。

**scavenge算法**是不断地搜索可被回收内存，将这些内存释放给系统使用。当搜索可被回收内存时，scavenge算法会根据对象是否有被引用来进行垃圾收集。如果没有被引用，则会被收集，从而释放占用的空间，维护系统的内存使用情况。

# 浏览器输入url后经历的过程?
1. 首先，在浏览器地址栏中输入url
2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。
4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
5. 握手成功后，浏览器向服务器发送http请求，请求数据包。
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到HTTP响应
8. 读取页面内容，浏览器渲染，解析html源码
9. 生成Dom树、解析css样式、js交互
10. 客户端和服务器交互
11. ajax查询

# DNS解析IP地址的过程？
DNS（Domain Name System）解析是一种用于将域名转换为IP地址的技术。当用户在浏览器中输入一个域名时，DNS解析器会将其转换为对应的IP地址，以便浏览器能够连接到正确的服务器。

DNS解析的过程包括以下几个步骤：
1. **浏览器缓存查询**：浏览器会先检查自己的缓存中是否有对应域名的IP地址，如果有，则直接使用该地址。
2. **本地DNS查询**：如果浏览器缓存中没有找到对应的IP地址，浏览器会向本地DNS服务器发送询问。这些DNS服务器通常由用户的网络提供商提供。
3. **根域名服务器查询**：如果本地DNS服务器没有找到对应的IP地址，它会向根域名服务器发送询问。根域名服务器是所有域名解析的最顶层DNS服务器。
4. **权威DNS服务器查询**：根域名服务器会指示本地DNS服务器向与该域名对应的权威DNS服务器发送询问。权威DNS服务器维护着该域名的DNS记录，并能够提供该域名对应的IP地址

# defer和async的区别？
async和defer能将script的下载阶段变成异步执行（和 html解析同步进行）。

* defer总是在页面解析完成后执行，但是不会阻塞页面的渲染。有执行顺序，先定义的先被执行。
* async会在加载完成后立即执行，但是会阻塞页面的渲染。有执行顺序，只要加载完成就会立即执行。

# 浏览器事件机制
DOM事件流由三个阶段组成：捕获阶段、目标阶段和冒泡阶段。
1. **捕获阶段**：事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件。为了让事件到达最终目标之前拦截事件。
  比如点击一个div，则 click 事件会按这种顺序触发: document => \<html\> => \<body\> => \<div\>，即由 document 捕获后沿着 DOM 树依次向下传播，并在各节点上触发捕获事件，直到到达实际目标元素。
2. **目标阶段**：当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发(执行事件对应的函数)，然后会逆向回流，直到传播至最外层的文档节点。
3. **冒泡阶段**：事件在目标元素上触发后，会继续随着 DOM 树一层层往上冒泡，直到到达最外层的根节点。

所有事件都要经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获得焦点 focus 和失去焦点 blur 不会冒泡。

# e.target 和 e.currentTarget 区别？
* e.target 指的是触发事件时，用户点击的元素。
* e.currentTarget 是指当前正在处理事件的元素，它可能不止一个，比如通过冒泡机制，可能会触发除了被点击的元素外的另一些元素的事件处理程序。

```js
<ul>
  <li><span>hello 1</span></li>
</ul>
​
let ul = document.querySelectorAll('ul')[0]
let aLi = document.querySelectorAll('li')
ul.addEventListener('click',function(e){
  let oLi1 = e.target  
  let oLi2 = e.currentTarget
  console.log(oLi1)   //  被点击的li
  console.log(oLi2)   // ul
  console.og(oLi1===oLi2)  // false
})
```

# 首屏有哪些优化手段？
1. 缩小图像的大小，以便更快的加载。
2. 使用异步加载技术，例如异步 JavaScript 和异步 CSS，来减少阻塞渲染。
3. 使用内容分发网络 (CDN)，以便让用户从更近的服务器获取内容。
4. 使用 gzip 压缩技术来减小文件大小。
5. 缓存静态资源，以便在用户再次访问时能够更快的加载。
6. 减少重定向，以便更快的响应用户的请求。
7. 优化网站的代码，例如合并代码和删除无用的代码，以便更快的执行。

# Webpack怎么打包ES6？
Webpack是一个流行的JavaScript模块打包工具，可以将多个模块打包为一个或多个文件，便于浏览器加载和使用。

要使用Webpack打包ES6，需要在项目中安装Webpack和相应的babel插件，并在Webpack的配置文件（通常是webpack.config.js）中进行如下配置：

1. 在webpack.config.js文件的module.exports对象中，添加一个module属性，用于配置打包规则。
2. 在module属性中，添加一个rules数组，用于配置每个模块的打包规则。
3. 在rules数组中，添加一个规则对象，用于指定如何处理扩展名为.js的文件。该规则对象应该包含两个属性：test和use。

* test属性用于指定哪些文件应该被该规则处理。通常可以使用正则表达式匹配文件名。
* use属性用于指定如何处理匹配到的文件。通常可以指定一个或多个babel插件，用于将ES6代码转换为ES5代码。
例如，如果要使用babel-loader插件将所有扩展名为.js的文件转换为ES5代码，可以使用以下规则：
```
module: {
  rules: [
    {
      test: /\.js$/,
      use: ['babel-loader']
    }
  ]
}
```

# Web安全？
Web安全的一些方法包括：使用加密技术（如HTTPS）来保护数据传输；实施安全策略，限制不必要的网络请求；使用可靠的身份验证和授权机制；实施系统安全控制，如防火墙；实施应用程序安全控制，如输入验证；以及实施强大的日志监控系统。

前端安全的一些方法包括：使用安全的通信协议（如HTTPS）来保护数据传输；实施安全策略，限制不必要的网络请求；使用可靠的身份验证和授权机制；避免脚本注入攻击；实施防止XSS攻击的措施；以及使用安全的API。

# Webpack5的好处？
Webpack5拥有几大优势，包括更快的构建，更好的配置管理，JavaScript框架的树摇晃支持以及改进的模块统一。

# 微前端解决了什么痛点？优缺点？
微前端技术能够解决前端现有开发流程的一些痛点，例如复杂的服务器端组件集成、不统一的应用系统架构和弱化的可重用性等。它的优点包括业务组件重用。

# pnpm和yarn有什么优缺点？
PNPM的优点是它可以减少构建时间，并且它拥有独特的资源管理机制，使其成为开发者的理想选择。它的缺点是它的内存使用量非常高。
Yarn的优点是它可以从模块仓库中获取最新的软件包，并且它的安装速度非常快。此外，Yarn的内存使用效率也很高，因此能够提高构建性能。它的缺点是它不能共享资源。

# 前端性能指标有哪些？
前端性能指标包括：页面加载时间（Page Load Time）、白屏时间（First Paint Time）、DOM Ready 时间（DOM Ready Time）、用户可操作时间（User-Interactive Time）、资源加载速度（Resource Download Speed）、资源加载时间（Resource Load Time）、内存使用情况（Memory Usage）以及 CPU 使用（CPU Usage）等指标。

# Service Worker有什么作用？
Service Worker主要用于提升网页和应用的性能，它可以缓存资源和请求，从而使得页面加载速度更快，并且可以在离线状态下提供服务。它还可以接收 push 通知，从而可以实现后台自动更新，用户体验也会更好。

# JSONP跨域
jsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

```html
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```
