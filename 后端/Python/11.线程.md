# 线程
线程之间数据是共享的：
```python
# 线程
from threading import Thread
import time

li = []
def wdata():
  for i in range(5):
    li.append(i)
    time.sleep(0.2)
  print('写入的数据是：', li)

def rdata():
  print('读取的数据是：', li)

# 只允许在主函数中调用。禁止在其他函数中导入模块形式调用。
if __name__ == '__main__':
  t1 = Thread(target=wdata)
  t2 = Thread(target=rdata)
  # t1.start() # 写入的数据是： [0, 1, 2, 3, 4]
  # t1.join() # 等待t1线程执行完毕
  # t2.start() 读取的数据是： [0, 1, 2, 3, 4]
  # t2.join() # 等待t2线程执行完毕

  t1.start() # 读取的数据是： [0, 1, 2, 3]
  time.sleep(0.8) # 0.8秒后读取的数据是： [0, 1, 2, 3]
  t2.start() # 写入的数据是： [0, 1, 2, 3, 4]
```

线程之间资源是竞争的：
```python
# 线程
from threading import Thread

a = 0
b = 1000000

def add():
  for i in range(b):
    global a
    a += 1
  print("第一次：", a)

def sub():
  for i in range(b):
    global a
    a += 1
  print("第二次：", a)

# add() # 第一次： 1000000
# sub() # 第二次： 2000000

if __name__ == '__main__':
  t1 = Thread(target=add)
  t2 = Thread(target=sub)
  t1.start() # 第一次： 167585
  t2.start() # 第二次： 2000000
```

# 线程同步
两种方式：join和互斥锁。<br>
互斥锁：
1. acquire()：加锁
2. release()：解锁
两个方法必须成对出现，否则容易形成死锁。 
```python
# 线程
from threading import Thread, Lock

a = 0
b = 1000000
lock = Lock()

def add():
  lock.acquire() # 加锁
  for i in range(b):
    global a
    a += 1
  print("第一次：", a)
  lock.release() # 解锁

def sub():
  lock.acquire() # 加锁
  for i in range(b):
    global a
    a += 1
  print("第二次：", a)
  lock.release() # 解锁

if __name__ == '__main__':
  t1 = Thread(target=add)
  t2 = Thread(target=sub)
  t1.start() # 第一次： 1000000
  t2.start() # 第二次： 2000000
```

# 进程
进程是操作系统进行资源分配和调度的基本单位，是操作系统结构的基础。

## 进程的语法结构
multiprocessing模块提供了Process类来代表一个进程对象。<br>

Process类参数：
1. target：表示这个进程对象要执行的任务（函数）
2. args：表示传递给target函数的参数，args是一个元组类型
3. kwargs：表示传递给target函数的关键字参数，kwargs是一个字典类型

Process类常用方法：
1. start()：启动进程，并调用run()方法
2. run()：进程启动时运行的方法，可以自定义代码
3. join([timeout])：等待子进程结束或者等待多少秒后结束
4. is_alive()：判断进程是否还在执行
5. terminate()：不管任务是否完成，立即终止

常用属性：
1. name：进程的别名，默认为Process-N，N为整数
2. pid：当前进程的进程编号

```python
from multiprocessing import Process
import time

num = 0

def wdata():
  for i in range(5):
    print('写入的数据是：', i)
    global num
    num = i
    time.sleep(0.2)

def rdata():
  print('读取的数据是：', num)

if __name__ == '__main__':
  p1 = Process(target=wdata)
  p2 = Process(target=rdata)
  print(p1.name) # Process-1
  print(p2.name) # Process-2
  p1.start() # 写入的数据是： 0 ~ 4
  p1.join() # 等待p1进程执行完毕
  p2.start() # 读取的数据是： 0
  p2.join() # 等待p2进程执行完毕
```

```python
from multiprocessing import Process

def eat(name):
    print(f"{name} is eating")

def sleep(name):
    print(f"{name} is sleeping")

if __name__ == "__main__":
    p1 = Process(target=eat, args=("Alice",))
    p2 = Process(target=sleep, args=("Bob",))

    p1.start()
    p1.join()
    p2.start()
    print('p1存活状态：', p1.is_alive())
    print('p2存活状态：', p2.is_alive())
    p2.join()
    # Alice is eating
    # p1存活状态： False
    # p2存活状态： True
    # Bob is sleeping
```
