# 线程
线程之间数据是共享的：
```python
# 线程
from threading import Thread
import time

li = []
def wdata():
  for i in range(5):
    li.append(i)
    time.sleep(0.2)
  print('写入的数据是：', li)

def rdata():
  print('读取的数据是：', li)

# 只允许在主函数中调用。禁止在其他函数中导入模块形式调用。
if __name__ == '__main__':
  t1 = Thread(target=wdata)
  t2 = Thread(target=rdata)
  # t1.start() # 写入的数据是： [0, 1, 2, 3, 4]
  # t1.join() # 等待t1线程执行完毕
  # t2.start() 读取的数据是： [0, 1, 2, 3, 4]
  # t2.join() # 等待t2线程执行完毕

  t1.start() # 读取的数据是： [0, 1, 2, 3]
  time.sleep(0.8) # 0.8秒后读取的数据是： [0, 1, 2, 3]
  t2.start() # 写入的数据是： [0, 1, 2, 3, 4]
```

线程之间资源是竞争的：
```python
# 线程
from threading import Thread

a = 0
b = 1000000

def add():
  for i in range(b):
    global a
    a += 1
  print("第一次：", a)

def sub():
  for i in range(b):
    global a
    a += 1
  print("第二次：", a)

# add() # 第一次： 1000000
# sub() # 第二次： 2000000

if __name__ == '__main__':
  t1 = Thread(target=add)
  t2 = Thread(target=sub)
  t1.start() # 第一次： 167585
  t2.start() # 第二次： 2000000
```

# 线程同步
两种方式：join和互斥锁。
互斥锁：
1. acquire()：加锁
2. release()：解锁
两个方法必须成对出现，否则容易形成死锁。
```python
# 线程
from threading import Thread, Lock

a = 0
b = 1000000
lock = Lock()

def add():
  lock.acquire() # 加锁
  for i in range(b):
    global a
    a += 1
  print("第一次：", a)
  lock.release() # 解锁

def sub():
  lock.acquire() # 加锁
  for i in range(b):
    global a
    a += 1
  print("第二次：", a)
  lock.release() # 解锁

if __name__ == '__main__':
  t1 = Thread(target=add)
  t2 = Thread(target=sub)
  t1.start() # 第一次： 1000000
  t2.start() # 第二次： 2000000
```