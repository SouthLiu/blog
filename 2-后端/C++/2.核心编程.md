# 内存分区模型
* 代码区：存放函数体的二进制代码，由操作系统进行管理。
* 全局区：存放全局变量和静态变量以及变量。
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

# 程序运行前
### 在程序编译后，生成exe可执行程序，**未执行程序前**分为两个区域。
### **代码区**：
* 存放CPU执行的机器指令。
* 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存种有一份代码即可。
* 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令。
### **全局区**：
* 全局变量和静态变量存放在此。
* 全局区还包含了常量区，字符串常量和其他常量也存放在此。
* **该区域的数据在程序结束后由操作系统释放**。

# 栈区
### 由编译器自动分配释放，存放函数的参数值，局部变量等。
### 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。
```cpp
// 在32位编译器中打印结果不同，在64位编译器中打印结果相同，都为乱码。
int* test() {
	int num = 10;
	return &num;
}

void main() {
	int * data = test();
  // 第一次打印出10是由编译器为了防止用户错误操作而缓存了一次值。
	cout << *data << endl; // 10
	cout << *data << endl; // 1493805432

	system("pause");
}
```

# 堆区
### 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
### 在C++中主要利用**new**在堆区开辟内存。
```cpp
int* test() {
	int* num = new int(10);
	return num;
}

void main() {
	int * data = test();
	cout << *data << endl; // 10
	cout << *data << endl; // 10
	cout << *data << endl; // 10
	cout << *data << endl; // 10

	system("pause");
}
```

# new操作符
### 在C++中利用new操作符在堆区开辟数据。
### 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete。
### 语法: `new 数据类型`
### 利用new创建的数据，会返回该数据对应的类型的指针。
```cpp
int* test() {
	int* num = new int(10);
	return num;
}

void main() {
	int * data = test();
	cout << *data << endl; // 10
	delete data;
	cout << *data << endl; // 报错，内存已释放，无法访问

	system("pause");
}
```

### new数组：
```cpp
int* fun() {
	int* arr = new int[10];
	for (int i = 0; i < 10; i++) {
		arr[i] = i;
	}
	return arr;
}

void main() {
	int* arr = fun();
	for (int i = 0; i < 10; i++) {
		cout << arr[i] << endl;
	}
	// 释放数组堆需要加上中括号
	delete[] arr;
	//cout << arr[0] << endl; // 报错，无法调用已释放资源
	system("pause");
}
```

# 引用
### 作用：给变量起别名。
### 语法：`数据类型 &别名 = 原名`